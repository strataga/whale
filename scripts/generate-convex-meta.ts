import fs from "node:fs";
import path from "node:path";

type FnType = "query" | "mutation" | "action" | "httpAction";

type FnMeta = {
  type: FnType;
  auth?: "required" | "optional";
};

function inferAuth(kind: string): FnMeta["auth"] {
  if (kind.startsWith("auth") || kind.startsWith("admin")) return "required";
  if (kind.startsWith("public")) return "optional";
  return undefined;
}

function inferType(kind: string): FnType | null {
  if (kind.endsWith("Query")) return "query";
  if (kind.endsWith("Mutation")) return "mutation";
  if (kind.endsWith("Action")) return "action";
  if (kind.endsWith("Route")) return "httpAction";
  return null;
}

function main() {
  const repoRoot = process.cwd();
  const functionsDir = path.join(repoRoot, "convex", "functions");
  const outDir = path.join(repoRoot, "convex", "_generated");

  const files = fs
    .readdirSync(functionsDir)
    .filter((f) => f.endsWith(".ts"))
    .sort((a, b) => a.localeCompare(b));

  const meta: Record<string, Record<string, FnMeta>> = {};

  // Matches: export const foo = authQuery ... / export const foo = publicMutation ...
  const exportRe =
    /export\s+const\s+([A-Za-z0-9_]+)\s*=\s*(authQuery|authMutation|authAction|adminQuery|adminMutation|publicQuery|publicMutation|publicAction|privateQuery|privateMutation|privateAction|publicRoute)\b/g;

  for (const file of files) {
    const fullPath = path.join(functionsDir, file);
    const contents = fs.readFileSync(fullPath, "utf8");
    const moduleKey = `functions/${path.basename(file, ".ts")}`;

    let m: RegExpExecArray | null;
    const entries: Record<string, FnMeta> = {};
    while ((m = exportRe.exec(contents))) {
      const fnName = m[1]!;
      const kind = m[2]!;
      const type = inferType(kind);
      if (!type) continue;
      entries[fnName] = {
        type,
        auth: inferAuth(kind),
      };
    }

    // Only include modules that have recognized exports.
    if (Object.keys(entries).length) {
      meta[moduleKey] = Object.fromEntries(
        Object.entries(entries).sort(([a], [b]) => a.localeCompare(b)),
      );
    }
  }

  const banner = `/* eslint-disable */
/**
 * Generated CRPC metadata for better-convex.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED by scripts/generate-convex-meta.ts.
 *
 * To regenerate:
 *   node --experimental-strip-types scripts/generate-convex-meta.ts
 */
`;

  const body = `export const meta = ${JSON.stringify(meta, null, 2)} as const;\n`;

  fs.mkdirSync(outDir, { recursive: true });
  fs.writeFileSync(path.join(outDir, "meta.ts"), `${banner}\n${body}`, "utf8");

  const types = `/* eslint-disable */
/**
 * Generated helper types for better-convex.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED by scripts/generate-convex-meta.ts.
 */

import type { api } from "./api";
import type { meta } from "./meta";

export type Api = typeof api;
export type Meta = typeof meta;
`;

  fs.writeFileSync(path.join(outDir, "types.ts"), types, "utf8");

  // eslint-disable-next-line no-console
  console.log(`Wrote convex/_generated/meta.ts and convex/_generated/types.ts for ${Object.keys(meta).length} modules.`);
}

main();
